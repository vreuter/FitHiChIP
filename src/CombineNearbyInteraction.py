#!/usr/bin/env python

"""
Created: November 14,2017

Combines nearby interactions generated by FitHiChIP
by a connected component labeling algorithm
Author: Sourya Bhattacharyya
Vijay-Ay lab, LJI
"""

import os
import sys
from optparse import OptionParser
import networkx as nx

#==========================================================
""" 
this class defines a particular interaction
the key is (x,y) where x and y are the bin number (x < y)
"""
class Interaction(object):  
    def __init__(self, cc, pval, qval):
        self.contact = cc
        self.PValue = pval
        self.QValue = qval

    def _GetCC(self):
        return self.contact

    def _GetPVal(self):
        return self.PValue

    def _GetQVal(self, count=1):
        return self.QValue

#===============================================
def main():
    parser = OptionParser() #(usage=usage)
    parser.add_option("--InpFile", dest="InpFile", help="Input interaction file")
    parser.add_option("--headerInp", dest="headerInp", type="int", help="If 1, indicates that input interaction file has the header information. Default 0.")
    parser.add_option("--OutFile", dest="OutFile", help="Output merged interaction file")
    parser.add_option("--binsize", dest="binsize", type="int", help="Size of bins employed. DEFAULT 5 Kb.")
    parser.add_option("--conn", dest="connectivity_rule", type="int", help="Rule of connectivity ( 8 or 4). DEFAULT 8.")
    parser.set_defaults(InpFile=None, OutFile=None, binsize=5000, connectivity_rule=8)
    (options, args) = parser.parse_args()

    #===========================
    # process the input parameters
    #===========================
    if options.InpFile is not None:
        InpFile = options.InpFile
    else:
        sys.exit("Input file is not provided - quit !!")

    # output file storing the bed formatted interactions
    if options.OutFile is not None:
        OutFile = options.OutFile
    else:
        sys.exit("Output file is not specified - quit !!")

    bin_size = int(options.binsize)
    headerInp = int(options.headerInp)
    connectivity_rule = int(options.connectivity_rule)

    # open the output file
    # if input interaction file has header information, then dump the header in the output file as well
    fp_outInt = open(OutFile, 'w')

    if (headerInp == 1):
        fp_in = open(InpFile, 'r')
        l = fp_in.readline()
        contents = l.rstrip().split()
        # write the header corresponding to the chromosomes, contact count, P value and the Q value
        fp_outInt.write(contents[0] + '\t' + contents[1] + '\t' + contents[2] + '\t' + contents[3] + '\t' + contents[4] + '\t' + contents[5] + '\t' + contents[6] + '\t' + contents[len(contents) - 2] + '\t' + contents[len(contents) - 1] + '\t' + 'bin1_low' + '\t' + 'bin1_high' + '\t' + 'bin2_low' + '\t' + 'bin2_high' + '\t' + 'sumCC' + '\t' + 'StrongConn')
        fp_in.close()

    # list of chromosomes to be experimented
    TargetChrList = []
    for i in range(1, 23):
        curr_chr = 'chr' + str(i)
        TargetChrList.append(curr_chr)
    TargetChrList.append('chrX')
    TargetChrList.append('chrY')

    # output directory
    OutDir = os.path.dirname(os.path.realpath(OutFile))
    if 0:
        print 'OutDir: ', str(OutDir)

    #=========================================
    # loop to process individual chromosomes and corresponding data
    #=========================================
    for chridx in range(len(TargetChrList)):    #range(20, 21):
        curr_chr = TargetChrList[chridx]
        if 0:
            print 'Processing the chromosome: ', str(curr_chr)

        # extract the interactions of current chromosome from the complete set of interactions
        tempchrdumpfile = OutDir + '/Temp_chr_Dump.bed'
        if (headerInp == 1):
            awkcmd = "cat " + str(InpFile) + " | awk \'{if (NR>1 && $1==\"" + str(curr_chr) + "\" && $4==\"" + str(curr_chr) + "\"){print $0}}\' -  > " + str(tempchrdumpfile) 
        else:
            awkcmd = "cat " + str(InpFile) + " | awk \'{if ($1==\"" + str(curr_chr) + "\" && $4==\"" + str(curr_chr) + "\"){print $0}}\' -  > " + str(tempchrdumpfile)
        os.system(awkcmd)

        # check the number of dumped interactions
        num_Int = sum(1 for line in open(tempchrdumpfile))

        if (num_Int == 0):
            if 0:
                print 'Number of interactions for this chromosome = 0 --- continue'
            continue

        if 0:
            print 'Extracted interactions for the current chromosome'

        # extract also the max span of interactions (6th column maximum element)
        # so as to estimate the matrix size
        temp_log_file = OutDir + '/Temp.log'
        sys_cmd =  "cat " + str(tempchrdumpfile) + " | cut -f6 | sort -nr  > " + str(temp_log_file)
        os.system(sys_cmd)

        # max_coord = int((subprocess.Popen(sys_cmd, shell=True)).stdout.read())
        with open(temp_log_file, 'r') as fp_in:
            l = fp_in.readline()
            max_coord = int((l.rstrip()).split()[0])

        sys.stdout.flush()  # test

        # number of bins (matrix dimension)
        nbins = (max_coord / bin_size)
        if 0:
            print 'max_coord of the interactions: ', str(max_coord)
            print 'nbins: ', str(nbins)

        # create a graph which will store the interactions
        G = nx.Graph()

        # create a dictionary for storing the interactions
        CurrChrDict = dict()

        # now scan through the interactions of the extracted chromosome 
        # and create a dictionary whose keys are the interacting bin numbers
        with open(tempchrdumpfile, 'r') as fp:
            for line in fp:
                linecontents = (line.rstrip()).split()
                # we set the bin number according to the end coordinate
                bin1 = int(linecontents[2]) / bin_size
                bin2 = int(linecontents[5]) / bin_size
                if (bin1 < bin2):
                    curr_key = (bin1, bin2)
                else:
                    curr_key = (bin2, bin1)
                # assign the key to the dictionary
                # add the contact count, P value and Q value information as well
                CurrChrDict.setdefault(curr_key, Interaction(int(linecontents[6]), float(linecontents[len(linecontents) - 2]), float(linecontents[len(linecontents) - 1])))
                # add the node to the given graph as well
                G.add_node(curr_key)
                # debug
                # print 'Current interaction: ', str(line), '  ------ curr_key: ', curr_key

        # now check the nodes of G
        # assign edges of G according to the 8 / 4 connectivity rule (according to the input parameter)
        nodelist = G.nodes()
        
        for i in range(len(nodelist) - 1):
            node1 = nodelist[i]
            for j in range(i+1, len(nodelist)):
                node2 = nodelist[j]
                # print 'Checking the edge between node 1: ', node1, '  and node 2: ', node2
                # check if there should be an edge between node1 and node2
                # according to the desired connectivity rule
                if (connectivity_rule == 8):
                    if (abs(node1[0] - node2[0]) <= 1) and (abs(node1[1] - node2[1]) <= 1):
                        G.add_edge(node1, node2)
                        # print '8 connectivity Edge between node 1: ', node1, '  and node 2: ', node2
                if (connectivity_rule == 4):
                    if ((abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])) <= 1):
                        G.add_edge(node1, node2)
                        # print '4 connectivity Edge between node 1: ', node1, '  and node 2: ', node2

        # check the edges of G
        edgelist = G.edges()

        if 0:
            print 'No of nodes of G: ', G.number_of_nodes()
            print 'No of edges of G: ', G.number_of_edges()
            print 'Number of connected components of G: ', nx.number_connected_components(G)

        # scan through individual connected components
        # for each such connected component (list of interactions)
        # we find a representative interaction and print it in the final output file
        list_conn_comp = sorted(nx.connected_components(G), key = len, reverse=True)

        for i in range(len(list_conn_comp)):
            # a connected component - a particular list of connected nodes
            curr_comp_list = list(list_conn_comp[i])
            if 0:
                print '\n Processing the connected component no: ', i, '  list: ', str(curr_comp_list)

            # from the first interacting bin set, get the lower and higher bin index
            min_idx_bin1 = min([x[0] for x in curr_comp_list])
            max_idx_bin1 = max([x[0] for x in curr_comp_list])
            if 0:
                print 'min_idx_bin1: ', min_idx_bin1, ' max_idx_bin1: ', max_idx_bin1

            # get the span of coordinates for the first interacting bin (set)
            span_low_bin1 = (min_idx_bin1 - 1) * bin_size
            span_high_bin1 = max_idx_bin1 * bin_size
            if 0:
                print 'span_low_bin1: ', span_low_bin1, ' span_high_bin1: ', span_high_bin1

            # from the second interacting bin set, get the lower and higher bin index
            min_idx_bin2 = min([x[1] for x in curr_comp_list])
            max_idx_bin2 = max([x[1] for x in curr_comp_list])
            if 0:
                print 'min_idx_bin2: ', min_idx_bin2, ' max_idx_bin2: ', max_idx_bin2

            # get the span of coordinates for the first interacting bin (set)
            span_low_bin2 = (min_idx_bin2 - 1) * bin_size
            span_high_bin2 = max_idx_bin2 * bin_size
            if 0:
                print 'span_low_bin2: ', span_low_bin2, ' span_high_bin2: ', span_high_bin2

            # sum of contact counts for all the interacting bins within this set of connected nodes
            sum_cc = sum([CurrChrDict[x]._GetCC() for x in curr_comp_list])

            # now get the percentage of bin pairs within this set of connected component
            # having a significant interaction
            total_possible_bin_pairs = (max_idx_bin1 - min_idx_bin1 + 1) * (max_idx_bin2 - min_idx_bin2 + 1)
            possible_bin_pairs = 0
            for b1 in range(min_idx_bin1, (max_idx_bin1 + 1)):
                for b2 in range(min_idx_bin2, (max_idx_bin2 + 1)):
                    bin_pair_key = (b1, b2)
                    if bin_pair_key in CurrChrDict:
                        possible_bin_pairs = possible_bin_pairs + 1
            
            # % of bin pairs within the region spanned by this connected component
            # having significant interaction
            # the higher the %, the better this component is strongly connected
            Percent_Significant_BinPair = (possible_bin_pairs * 1.0) / total_possible_bin_pairs

            if 0:
                print 'total_possible_bin_pairs: ', total_possible_bin_pairs, ' possible_bin_pairs: ', possible_bin_pairs, ' % clique: ', Percent_Significant_BinPair

            # get the min P and Q values and corresponding bin pairs
            for j in range(len(curr_comp_list)):
                curr_key = curr_comp_list[j]
                if 0:
                    print ' Connected component index: ', j, ' curr_key: ', curr_key, ' CC: ', CurrChrDict[curr_key]._GetCC(), ' Pval: ', CurrChrDict[curr_key]._GetPVal(), ' Qval: ', CurrChrDict[curr_key]._GetQVal()
                if (j == 0):
                    rep_bin_key = curr_key
                else:
                    if (CurrChrDict[curr_key]._GetPVal() < CurrChrDict[rep_bin_key]._GetPVal()) and (CurrChrDict[curr_key]._GetQVal() < CurrChrDict[rep_bin_key]._GetQVal()):
                        rep_bin_key = curr_key

            # fix the representative interaction
            rep_bin1_low = (rep_bin_key[0] - 1) * bin_size
            rep_bin1_high = rep_bin_key[0] * bin_size
            rep_bin2_low = (rep_bin_key[1] - 1) * bin_size
            rep_bin2_high = rep_bin_key[1] * bin_size
            cc = CurrChrDict[rep_bin_key]._GetCC()
            pval = CurrChrDict[rep_bin_key]._GetPVal()
            qval = CurrChrDict[rep_bin_key]._GetQVal()

            if 0:
                print 'Selected bin key: ', rep_bin_key,  ' cc: ', cc, ' pval: ', pval, ' qval: ', qval
                       
            # write the interaction in the specified output file
            fp_outInt.write('\n' + str(curr_chr) + '\t' + str(rep_bin1_low) + '\t' + str(rep_bin1_high) + '\t' + str(curr_chr) + '\t' + str(rep_bin2_low) + '\t' + str(rep_bin2_high) + '\t' + str(cc) + '\t' + str(pval) + '\t' + str(qval) + '\t' + str(span_low_bin1) + '\t' + str(span_high_bin1) + '\t' + str(span_low_bin2) + '\t' + str(span_high_bin2) + '\t' + str(sum_cc) + '\t' + str(Percent_Significant_BinPair))


    # after processing all the chromosomes, now close the output interaction file
    fp_outInt.close()

    # remove the temp log file which stores the max coordinate for a chromosome
    sys_cmd = "rm " + str(temp_log_file)
    os.system(sys_cmd)

    # remove the temporary chromosome specific interaction dump file
    sys_cmd = "rm " + str(tempchrdumpfile)
    os.system(sys_cmd)

    if 0:
        print 'End of merging nearby interactions !!! '

#===============================================
if __name__ == "__main__":
    main()

